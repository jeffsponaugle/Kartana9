LISTING FOR LOGIC DESCRIPTION FILE: PC.pld                           Page 1

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Dec 29 16:26:17 2023

  1:Name     PCPTR;
  2:PartNo   PCPTR;
  3:Date     04/18/2022;
  4:Revision 01;
  5:Designer Sponaugle;
  6:Company  Ratiometric;
  7:Assembly None;
  8:Location None;
  9:Device   f1508ispplcc84;
 10:      
 11:
 12:PROPERTY ATMEL {TDI_PULLUP = ON};
 13:PROPERTY ATMEL {TMS_PULLUP = ON};
 14:PROPERTY ATMEL {PREASSIGN = KEEP};
 15:PROPERTY ATMEL {XOR_SYNTHESIS = OFF};
 16:
 17:/* Input Pins */
 18:
 19:Pin[44,45,46]  = [PC_MODE0..2];
 20:Pin[2]  = ADBUS_OE;
 21:Pin[84]  = BBUS_OE;
 22:Pin[83]  = D_CLK_IN;
 23:Pin[1]  = RESET_IN;
 24:Pin[55] = CF_IN;
 25:Pin[57] = OVF_IN;
 26:Pin[56] = ZF_IN;
 27:Pin[60,61,63] = [JCOND0..2];
 28:Pin[58] = JMPINST;     /* Active Low input to indicate a jump instruction is executing */
 29:
 30:/* Output Pins */
 31:
 32:Pin[41,39,40,37,36,35,33,34,31,29,30,28,27,25,24]  = [ADBUS1..15];   
 33:
 34:/* Bidirectional Pins */
 35:
 36:Pin[20,22,21,18,17,15,16,12,11,10,8,9,6,5,4]  = [BBUS1..15];
 37:
 38:           
 39:
 40:PINNODE [0..0] = [PC0..15];       /* The actual program counter register, 16 bits wide */
 41:PINNODE [0..0] = [C2..15];
 42:PINNODE [0..0] = [S1..15];
 43:
 44:[ADBUS1..15].oe = !ADBUS_OE;
 45:[BBUS1..15].oe = !BBUS_OE;
 46:
 47:[ADBUS1..15] = ((!PC_MODE2) & [PC1..15]) 
 48:                # (PC_MODE2 & [S1..15]);
 49:[BBUS1..15] = [PC1..15];
 50:
 51:
 52:/*
 53:

LISTING FOR LOGIC DESCRIPTION FILE: PC.pld                           Page 2

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Dec 29 16:26:17 2023

 54:        PC_MODE Inputs  2/1/0 (3 bits)
 55:        000          Do Nothing
 56:        001          Increment PC Register by 2 (bit 0 is always 0)  [FETCH]
 57:        010          Load PC Register from BBUS [JMP DIRECT, CALL DIRECT]
 58:        011          Add to PC Register from BBUS (Relative Jump), ignore bit 0 from BBUS, latch back into PC. [JMP RELATIVE, CALL RELATIVE]
 59:        100          Add PC Register Value to BBUS and output on AD immediatly, but don't latch back into the PC register
 60:
 61:*/
 62:
 63:
 64:/* Handle Jump conditions.  
 65:  If JMPINST == 0, that indicates we are doing a jump instruction and we need to compare the flags based
 66:  on the jump condition, and if a jump should occur force PC_MODE1 high.
 67:
 68:  Jump Condition Code               Condition
 69:  000                               Always Jump
 70:  001                               Jump if ZF==1
 71:  010                               Jump if ZF==0
 72:  011                               Jump if CF==1
 73:  100                               Jump if CF==0
 74:  101                               Jump if OVF==1
 75:  110                               Jump if OVF==0
 76:  111                               Always Jump
 77:
 78:  */
 79:
 80:FIELD jumpc = [JCOND0..2];
 81:
 82:/* FORCEJUMP == 1 if we want to force a jump to occur.  This happens if both JMPINST==0, and  
 83:   the conditions are a correct match for the jump to occur.   If this is true, FORCEJUMP will force
 84:   the upper bit of PC_MODE to 1, which will force either a LOAD PC or ADD PC */
 85:
 86:JUMPCONDITION =( ( jumpc:['b'000] )
 87:            # ( jumpc:['b'001] & ZF_IN )
 88:            # ( jumpc:['b'010] & !ZF_IN )
 89:            # ( jumpc:['b'011] & CF_IN )
 90:            # ( jumpc:['b'100] & !CF_IN )
 91:            # ( jumpc:['b'101] & OVF_IN )
 92:            # ( jumpc:['b'110] & !OVF_IN )
 93:            # ( jumpc:['b'111]));
 94:
 95:/* Let's fix up PC_MODE by creating PC_MODEJ, which as the addition of the jump modification.
 96:
 97:   If JUMPCONDITION == 0 and JMPINST == 0 (Jump instruction, but don't jump)
 98:     PC_MODE      PC_MODEJ
 99:      X00            X00
100:      X01            X00
101:   If JUMPCONDITION == 1 and JMPINST == 0 (Jump instructio, jump)
102:    PC_MODE      PC_MODEJ
103:      X00            X10
104:      X01            X11
105:   If JMPINST == 1
106:     PC_MODE      PC_MODEJ
107:      X00            X00

LISTING FOR LOGIC DESCRIPTION FILE: PC.pld                           Page 3

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Dec 29 16:26:17 2023

108:      X01            X01
109:
110:
111: */
112:
113://PINNODE  0  = PC_MODEJ1,PC_MODEJ0;

114:PC_MODEJ0 = PC_MODE0 & (JMPINST # JUMPCONDITION);
115:PC_MODEJ1 = PC_MODE1 # (!JMPINST & JUMPCONDITION);
116:PC_MODEJ2 = PC_MODE2;
117:FIELD pcmode = [PC_MODEJ0..2];
118:
119:
120:/* PC Adder/Subtractor Equations
121:
122:    To Add 1 (PC_MODE==001), set C1=1, and B1..B15=0
123:    To Add Offset (PC_MODE=011 or PC_MODE=100), set C0=0, and B0..B15=BBUS0..BBUS15
124:    PC must always have bit0=0, so on load we will not load bit 0, but on output
125:    we will output a zero.
126:
127:    When we add a offset from BBUS to PC BBUS bit 0 is ignored.
128:
129:*/
130:
131:C1 = (PC_MODEJ0 & !PC_MODEJ1 & !PC_MODEJ2);  // if PC_MODE = 001, set carry in to 1, otherwise 0

132:/* 
133:   For the [B1..B15], we want the [B] field to be the BBUS value if we are in PC_MODE 010,011, or 1XX. 
134:   IF PC_MODE is 000 or 001 the [B] field is 0.
135:
136:   Note that for PC_MODE 010 the result of the addition will not be used, but including that simplifies 
137:   the logic.
138:   */
139:
140:[B1..B15] = ((PC_MODEJ1#PC_MODEJ2) & [BBUS1..BBUS15].io);
141:[A1..A15] = [PC1..PC15];
142:
143:
144:P1 = A1 $ B1;
145:G1 = A1 & B1;
146:S1 = P1 $ C1;
147:C2 = G1 # (P1&C1);
148:
149:P2 = A2 $ B2;
150:G2 = A2 & B2;
151:S2 = P2 $ C2;
152:C3 = G2 # (P2&C2);
153:
154:P3 = A3 $ B3;
155:G3 = A3 & B3;
156:S3 = P3 $ C3;
157:C4 = G3 # (P3&C3);
158:
159:P4 = A4 $ B4;
160:G4 = A4 & B4;
161:S4 = P4 $ C4;

LISTING FOR LOGIC DESCRIPTION FILE: PC.pld                           Page 4

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Dec 29 16:26:17 2023

162:C5 = G4 # (P4&C4);
163:
164:P5 = A5 $ B5;
165:G5 = A5 & B5;
166:S5 = P5 $ C5;
167:C6 = G5 # (P5&C5);
168:
169:P6 = A6 $ B6;
170:G6 = A6 & B6;
171:S6 = P6 $ C6;
172:C7 = G6 # (P6&C6);
173:
174:P7 = A7 $ B7;
175:G7 = A7 & B7;
176:S7 = P7 $ C7;
177:C8 = G7 # (P7&C7);
178:
179:P8 = A8 $ B8;
180:G8 = A8 & B8;
181:S8 = P8 $ C8;
182:C9 = G8 # (P8&C8);
183:
184:P9 = A9 $ B9;
185:G9 = A9 & B9;
186:S9 = P9 $ C9;
187:C10 = G9 # (P9&C9);
188:
189:P10 = A10 $ B10;
190:G10 = A10 & B10;
191:S10 = P10 $ C10;
192:C11 = G10 # (P10&C10);
193:
194:P11= A11 $ B11;
195:G11 = A11 & B11;
196:S11 = P11 $ C11;
197:C12 = G11 # (P11&C11);
198:
199:P12 = A12 $ B12;
200:G12 = A12 & B12;
201:S12 = P12 $ C12;
202:C13 = G12 # (P12&C12);
203:
204:P13 = A13 $ B13;
205:G13 = A13 & B13;
206:S13 = P13 $ C13;
207:C14 = G13 # (P13&C13);
208:
209:P14 = A14 $ B14;
210:G14 = A14 & B14;
211:S14 = P14 $ C14;
212:C15 = G14 # (P14&C14);
213:
214:P15 = A15 $ B15;
215:G15 = A15 & B15;

LISTING FOR LOGIC DESCRIPTION FILE: PC.pld                           Page 5

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Dec 29 16:26:17 2023

216:S15 = P15 $ C15;
217:
218:
219:
220:
221:
222:/* Program Counter 
223:
224:   bit 0 is always 0 in the program counter, so bit0 is never loaded, but always output
225:*/
226:
227:PC_STAY = pcmode:['b'X00];
228:PC_ADD  = pcmode:['b'001,'b'011];
229:PC_LOAD = pcmode:['b'010];
230:
231:PC0.d = 'd'0;
232:PC0.ck = D_CLK_IN;
233:PC0.ar = !RESET_IN;
234:
235:PC1.d = ((PC_ADD & S1) # (PC_STAY & PC1) # (PC_LOAD & BBUS1.io));
236:PC1.ck = D_CLK_IN;
237:PC1.ar = !RESET_IN;
238:
239:PC2.d = ((PC_ADD & S2) # (PC_STAY & PC2) # (PC_LOAD & BBUS2.io));
240:PC2.ck = D_CLK_IN;
241:PC2.ar = !RESET_IN;
242:
243:PC3.d = ((PC_ADD & S3) # (PC_STAY & PC3) # (PC_LOAD & BBUS3.io));
244:PC3.ck = D_CLK_IN;
245:PC3.ar = !RESET_IN;
246:
247:PC4.d = ((PC_ADD & S4) # (PC_STAY & PC4) # (PC_LOAD & BBUS4.io));
248:PC4.ck = D_CLK_IN;
249:PC4.ar = !RESET_IN;
250:
251:PC5.d = ((PC_ADD & S5) # (PC_STAY & PC5) # (PC_LOAD & BBUS5.io));
252:PC5.ck = D_CLK_IN;
253:PC5.ar = !RESET_IN;
254:
255:PC6.d = ((PC_ADD & S6) # (PC_STAY & PC6) # (PC_LOAD & BBUS6.io));
256:PC6.ck = D_CLK_IN;
257:PC6.ar = !RESET_IN;
258:
259:PC7.d = ((PC_ADD & S7) # (PC_STAY & PC7) # (PC_LOAD & BBUS7.io));
260:PC7.ck = D_CLK_IN;
261:PC7.ar = !RESET_IN;
262:
263:PC8.d = ((PC_ADD & S8) # (PC_STAY & PC8) # (PC_LOAD & BBUS8.io));
264:PC8.ck = D_CLK_IN;
265:PC8.ar = !RESET_IN;
266:
267:PC9.d = ((PC_ADD & S9) # (PC_STAY & PC9) # (PC_LOAD & BBUS9.io));
268:PC9.ck = D_CLK_IN;
269:PC9.ar = !RESET_IN;

LISTING FOR LOGIC DESCRIPTION FILE: PC.pld                           Page 6

CUPL(WM): Universal Compiler for Programmable Logic
Version 5.0a Serial# 60008009
Copyright (c) 1983, 1998 Logical Devices, Inc.
Created Fri Dec 29 16:26:17 2023

270:
271:PC10.d = ((PC_ADD & S10) # (PC_STAY & PC10) # (PC_LOAD & BBUS10.io));
272:PC10.ck = D_CLK_IN;
273:PC10.ar = !RESET_IN;
274:
275:PC11.d = ((PC_ADD & S11) # (PC_STAY & PC11) # (PC_LOAD & BBUS11.io));
276:PC11.ck = D_CLK_IN;
277:PC11.ar = !RESET_IN;
278:
279:PC12.d = ((PC_ADD & S12) # (PC_STAY & PC12) # (PC_LOAD & BBUS12.io));
280:PC12.ck = D_CLK_IN;
281:PC12.ar = !RESET_IN;
282:
283:PC13.d = ((PC_ADD & S13) # (PC_STAY & PC13) # (PC_LOAD & BBUS13.io));
284:PC13.ck = D_CLK_IN;
285:PC13.ar = !RESET_IN;
286:
287:PC14.d = ((PC_ADD & S14) # (PC_STAY & PC14) # (PC_LOAD & BBUS14.io));
288:PC14.ck = D_CLK_IN;
289:PC14.ar = !RESET_IN;
290:
291:PC15.d = ((PC_ADD & S15) # (PC_STAY & PC15) # (PC_LOAD & BBUS15.io));
292:PC15.ck = D_CLK_IN;
293:PC15.ar = !RESET_IN;
294:
295:
296:
297:/*
298:Total dedicated input used:     4/4     (100%)
299:Total I/O pins used             44/64   (68%)
300:Total Logic cells used          97/128  (75%)
301:Total Flip-Flop used            16/128  (12%)
302:Total Foldback logic used       6/128   (4%)
303:Total Nodes+FB/MCells           102/128         (79%)
304:Total cascade used              1
305:Total input pins                18
306:Total output pins               30
307:Total Pts                       235
308:
309:
310:
311:*/
312:
313:
314:
315:
316:
317:
318:
319:
320:
321:
322:
323:



